\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{url}

\oddsidemargin -10mm
\evensidemargin -10mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{Assignment 3, Part 1, Specification}
\author{SFWR ENG 2AA4}

\begin {document}

\maketitle
This Module Interface Specification (MIS) document contains modules, types and
methods for implementing the state of a game of Forty Thieves solitaire.

\wss{The parts that you need to fill in are marked by comments, like this one.
  In several of the modules local functions are specified.  You can use these
  local functions to complete the missing specifications.}

\wss{As you edit the tex source, please leave the \texttt{wss} comments in the
  file.  Put your answer \textbf{before} the comment.  This will make grading
  easier.}\\
  
Worked with Kanakabha Choudhri for some of the functions.

\newpage

\section* {Card Types Module}

\subsection*{Module}

CardTypes

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Constants}

TOTAL\_CARDS = 104\\
ACE = 1\\
JACK = 11\\
QUEEN = 12\\
KING = 13

\subsubsection* {Exported Types}

SuitT = \{Heart, Diamond, Club, Spade\}\\ 
RankT = [1..13]\\
CategoryT = \{Tableau, Foundation, Deck, Waste\}\\
CardT = tuple of (s: SuitT, r: RankT)

\subsubsection* {Exported Access Programs}

None

\subsection* {Semantics}

\subsubsection* {State Variables}

None

\subsubsection* {State Invariant}

None

\newpage

\section* {Generic Stack Module}

\subsection* {Generic Template Module}

Stack(T)

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}

Stack = ?

\wss{What should be written here?}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new Stack & seq of T & Stack & none\\
\hline
push & T & Stack & none\\
\hline
pop & & Stack & out\_of\_range\\
\hline
top & & T & out\_of\_range\\
\hline
size & & $\mathbb{N}$ & \\
\hline
toSeq& & seq of T & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$S$: Sequence of T \wss{What is the type of the state variable?}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions \& Design Decisions}

\begin{itemize}
\item The Stack(T) constructor is called for each object instance before any
  other access routine is called for that object.  The constructor can only be
  called once.
\item Though the toSeq() method violates the essential property of the stack
  object, since this could be achieved by calling top and pop many times, this
  method is provided as a convenience to the client. In fact, it increases the
  property of separation of concerns since this means that the client does not
  have to worry about details of building their own sequence from the sequence
  of pops.
\end{itemize}

\subsubsection* {Access Routine Semantics}

new Stack($s$):
\begin{itemize}
\item transition: $S := s$

\item output: $\mathit{out} := \mathit{self}$
\item exception: none
\end{itemize}

\noindent push($e$):
\begin{itemize}
\item output: $out := \text{new Stack}(S\ ||\ \langle e \rangle)$
\item exception: none
\end{itemize}

\noindent pop():
\begin{itemize}
\item output: $S := S[0..|S|-2]$ \wss{What should go here?}

\item exception: $exc := (|S| = 0 \Rightarrow$ EMPTY)  \wss{What should go here?}

\end{itemize}

\noindent top():
\begin{itemize}
\item output: $\mathit{out} := S[|S| - 1]$

\item exception: $exc := (|S| = 0 \Rightarrow$ EMPTY) \wss{What should go here?}

\end{itemize}

\noindent size():
\begin{itemize}
\item output: $out := |S|$ \wss{What should go here?}
\item exception: None
\end{itemize}

\noindent toSeq():
\begin{itemize}
\item output: $\mathit{out} := S$
\item exception: None

\end{itemize}

\newpage

\section* {CardStack Module}

\subsection* {Template Module}

CardStackT is Stack(CardT) \wss{What should go here?}

\newpage

\section* {Game Board ADT Module}

\subsection*{Template Module}

BoardT

\subsection* {Uses}

\noindent CardTypes\\
\noindent CardStack

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new BoardT  & seq of CardT & BoardT & invalid\_argument\\
\hline
is\_valid\_tab\_mv & CategoryT, $\mathbb{N}$, $\mathbb{N}$ & $\mathbb{B}$ & out\_of\_range\\
\hline
is\_valid\_waste\_mv & CategoryT, $\mathbb{N}$ & $\mathbb{B}$ &
                                                                invalid\_argument, out\_of\_range\\
\hline
is\_valid\_deck\_mv &  &  $\mathbb{B}$ & \\
\hline
tab\_mv & CategoryT, $\mathbb{N}$, $\mathbb{N}$ & & invalid\_argument\\
\hline
waste\_mv & CategoryT, $\mathbb{N}$ & & invalid\_argument\\
\hline
deck\_mv &  & & invalid\_argument\\
\hline
get\_tab & $\mathbb{N}$ & CardStackT & out\_of\_range\\
\hline
get\_foundation & $\mathbb{N}$ & CardStackT & out\_of\_range\\
\hline
get\_deck &  & CardStackT & \\
\hline
get\_waste &  & CardStackT & \\
\hline
valid\_mv\_exists & & $\mathbb{B}$ &\\
\hline
is\_win\_state & & $\mathbb{B}$ & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$T$: SeqCrdStckT \textit{\# Tableau}\\
$F$: SeqCrdStckT \textit{\# Foundation}\\
$D$: CardStackT \textit{\# Deck}\\
$W$: CardStackT \textit{\# Waste}\\

\subsubsection* {State Invariant}

$|T| \le $ $ $TOTAL\_CARDS $ \wss{\text{What goes here?}}$\\
$|F| \le $ $ $TOTAL\_CARDS $ \wss{\text{What goes here?}}$\\
cnt\_cards($T$, $F$, $D$, $W$, $f$ \wss{\text{What goes here?}}) = TOTAL\_CARDS\\

f = $(\forall c:CardT | c \in (T \cup F \cup  D \cup  W) : True) $ \\

two\_decks($T$, $F$, $D$, $W$) \textit{\# each card appears twice in the combined deck}

\subsubsection* {Assumptions \& Design Decisions}

\begin{itemize}

\item The BoardT constructor is called before any other access
  routine is called on that instance. Once a BoardT has been created, the
  constructor will not be called on it again.

\item The Foundation stacks must start with an ace, but any Foundation stack can
  start with any suit. Once an Ace of that suit is placed there, this Foundation
  stack becomes that type of stack and only those type of cards can be placed
  there.

\item Once a card has been moved to a Foundation stack, it cannot be moved again.

\item For better scalability, this module is specified as an Abstract Data Type
  (ADT) instead of an Abstract Object. This would allow multiple games to be
  created and tracked at once by a client.

\item The getter function is provided, though violating the property of being
  essential, to give a would-be view function easy access to the state of the
  game. This ensures that the model is able to be easily integrated with a game
  system in the future.  Although outside of the scope of this assignment, the
  view function could be part of a Model View Controller design pattern implementation
  (\url{https://blog.codinghorror.com/understanding-model-view-controller/})

\item A function will be available to create a double deck of cards that
  consists of a random permutation of two regular decks of cards (TOTAL\_CARDS
  cards total).  This double deck of cards can be used to build the game board.

\end{itemize}

\subsubsection* {Access Routine Semantics}

\noindent GameBoard($\mathit{deck}$):
\begin{itemize}
\item transition: 
$$T, F, D, W := \text{tab\_deck}(\mathit{deck}[0..39]),
  \text{init\_seq}(8), \text{CardStackT}(\mathit{deck}[40..103]),
  \text{CardStackT}(\langle \rangle)$$
\item exception: $exc := (\lnot \text{two\_decks}(\text{init\_seq}(10),
  \text{init\_seq}(8), \text{CardStackT}(\mathit{deck}),
  \text{CardStackT}(\langle \rangle) ) \Rightarrow \text{invalid\_argument})$
\end{itemize}

\newpage

\noindent is\_valid\_tab\_mv($c, n_0, n_1$):
\begin{itemize}
\item output:

\begin{tabular}{|p{3cm}|l|}
\hhline{~|-|}
\multicolumn{1}{r|}{} & \multicolumn{1}{l|}{$out :=$}\\
\hhline{|-|-|}
$c = \mbox{Tableau}$ & valid\_tab\_tab($n_0$,$n_1$) \\
\hhline{|-|-|}
$c = \mbox{Foundation}$ & valid\_tab\_foundation($n_0$,$n_1$) \\
\hhline{|-|-|}
$c = \mbox{Deck}$& False \wss{What goes here?}\\
\hhline{|-|-|}
$c = \mbox{Waste}$ & False \wss{What goes here?}\\
\hhline{|-|-|}
\end{tabular}

\item exception:

\begin{tabular}{|p{14cm}|l|}
  \hhline{~|-|}
  \multicolumn{1}{r|}{} & \multicolumn{1}{l|}{$exc :=$}\\
  \hhline{|-|-|}
  $c = \mbox{Tableau} \wedge \neg(\text{is\_valid\_pos}(\text{Tableau}, n_0) \wedge
  \text{is\_valid\_pos}(\text{Tableau}, n_1))$ & out\_of\_range\\
  \hhline{|-|-|}
  $c = \mbox{Foundation} \wedge \neg(\text{is\_valid\_pos}(\text{Tableau}, n_0) \wedge
  \text{is\_valid\_pos}(\text{Foundation}, n_1))$ & out\_of\_range\\
  \hhline{|-|-|}
\end{tabular}
\end{itemize}

\noindent is\_valid\_waste\_mv($c, n$):
\begin{itemize}
\item output:

\begin{tabular}{|p{3cm}|l|}
\hhline{~|-|}
\multicolumn{1}{r|}{} & \multicolumn{1}{l|}{$out :=$}\\
\hhline{|-|-|}
$c = \mbox{Tableau}$ & valid\_waste\_tab($n$) \\
\hhline{|-|-|}
$c = \mbox{Foundation}$ & valid\_waste\_foundation($n$) \\
\hhline{|-|-|}
$c = \mbox{Deck}$& False \wss{What goes here?}\\
\hhline{|-|-|}
$c = \mbox{Waste}$ & False \wss{What goes here?}\\
\hhline{|-|-|}
\end{tabular}

\item exception:

\begin{tabular}{|p{10cm}|l|}
  \hhline{~|-|}
  \multicolumn{1}{r|}{} & \multicolumn{1}{l|}{$exc :=$}\\
  \hhline{|-|-|}
  $\text{W.size()} = 0$ & invalid\_argument\\
  \hhline{|-|-|}
  $c = \mbox{Tableau} \wedge \neg \text{is\_valid\_pos}(\text{Tableau}, n)$ & out\_of\_range\\
  \hhline{|-|-|}
  $c = \mbox{Foundation} \wedge \neg \text{is\_valid\_pos}(\text{Foundation}, n)$ & out\_of\_range\\
  \hhline{|-|-|}
\end{tabular}
\end{itemize}

\noindent is\_valid\_deck\_mv():
\begin{itemize}
\item output: $out := 63 > |D| > 0$ \wss{What goes here?  The deck moves involves moving a card from
    the deck stack to the waste stack.}
\item exception: None
\end{itemize}

\noindent tab\_mv($c, n_0, n_1$):
\begin{itemize}
\item transition:

\begin{tabular}{|p{3cm}|l|}
\hhline{|-|-|}
$c = \mbox{Tableau}$ & T[$n_0$], T[$n_1$] := T[$n_0$].pop(), T[$n_1$].push(T[$n_0$][$|$T[$n_0$]$|$ - 1]) \wss{What goes here?}\\
\hhline{|-|-|}
$c = \mbox{Foundation}$ & T[$n_0$], F[$n_1$] := T[$n_0$].pop(), F[$n_1$].push(T[$n_0$][$|$T[$n_0$]$|$ - 1]) \wss{What goes here?}\\
\hhline{|-|-|}
\end{tabular}

\item exception: $exc := (\neg \text{is\_valid\_tab\_mv}(c, n_0, n_1)
  \Rightarrow \text{invalid\_argument})$

\end{itemize}

\noindent waste\_mv($c, n$):
\begin{itemize}
\item transition:

\begin{tabular}{|p{3cm}|l|}
\hhline{|-|-|}
$c = \mbox{Tableau}$ & W, T[$n$] := W.pop(), T[n].push(W[$|$W$|$ - 1]) \wss{What goes here?}\\
\hhline{|-|-|}
$c = \mbox{Foundation}$ & W, F[$n$] :=  W.pop(), F[n].push(W[$|$W$|$ - 1]) \wss{What goes here?}\\
\hhline{|-|-|}
\end{tabular}

\item exception:
  $exc := (\neg \text{is\_valid\_waste\_mv}(c, n) \Rightarrow
  \text{invalid\_argument})$

\end{itemize}

\noindent deck\_mv():
\begin{itemize}
\item transition: D, W := D.pop(), W.push(D[$|$D$|$ - 1])\wss{What goes here?}
\item exception:
  $exc := (\neg \text{is\_valid\_deck\_mv}() \Rightarrow \text{invalid\_argument})$
\end{itemize}

\noindent get\_tab($i$):
\begin{itemize}
\item output: $out := T[i]$
\item exception: $exc : (\neg \text{is\_valid\_pos}(\text{Tableau}, i) \Rightarrow \text{out\_of\_range})$
\end{itemize}

\noindent get\_foundation($i$):
\begin{itemize}
\item output: $out := F[i]$
\item exception: $exc : (\neg \text{is\_valid\_pos}(\text{Foundation}, i) \Rightarrow \text{out\_of\_range})$
\end{itemize}

\noindent get\_deck():
\begin{itemize}
\item output: $out := D$
\item exception: None
\end{itemize}

\noindent get\_waste():
\begin{itemize}
\item output: $out := W$
\item exception: None
\end{itemize}

\noindent valid\_mv\_exists():
\begin{itemize}
\item output: $out := \text{valid\_tab\_mv} \vee \text{valid\_waste\_mv} \vee
  \text{is\_valid\_deck\_mv()}$ where\\

  $\text{valid\_tab\_mv} \equiv (\exists c: \text{CategoryT}, n_0: \mathbb{N},
  n_1: \mathbb{N} | (c: T \land n_0 \in [0..9] ) \lor (c:F \land n_1 \in [0..12])\wss{\text{What goes here?}}: \text{is\_valid\_tab\_mv}(c, n_0, n_1))$\\

  $\text{valid\_waste\_mv} \equiv (\exists c: \text{CategoryT}, n: \mathbb{N} |
  (c: T \land n \in [0..63]) \lor (c: F \land n \in [0..63])\wss{\text{What goes here?}} : \text{is\_valid\_waste\_mv}(c, n))$

\item exception: None

\end{itemize}

\noindent is\_win\_state():
\begin{itemize}
\item output: $out := (\forall s : CardStackT|s \in F: |s| = 13) $ \wss{What goes here?}
\item exception: None

\end{itemize}

\subsection*{Local Types}

SeqCrdStckT = seq of CardStackT

\subsection*{Local Functions}

\noindent $\text{two\_decks} : \text{SeqCrdStckT} \times \text{SeqCrdStckT}
\times \text{CardStackT} \times \text{CardStackT} \rightarrow \mathbb{B}$\\
\noindent
$\text{two\_decks}(T, F, D, W) \equiv$ \wss{This function returns True if there
  is two of each card in the game}\newline
  \newline
$(\forall \mathit{st}: \text{SuitT}, \mathit{rk}:
\text{RankT} | \mathit{st} \in \text{SuitT} \wedge \mathit{rk} \in \text{RankT}
:$ $\newline(\exists n_0, n_1: CardT| n_0, n_1 \in (T \cup F \cup D \cup W): (n_0.st = n_1.st) \land (n_0.rk = n_1.rk)))\wss{\text{What goes here?}})$\\



\noindent $\text{cnt\_cards\_seq}: \text{SeqCrdStckT} \times (\text{CardT}
\rightarrow \mathbb{B}) \rightarrow \mathbb{N}$\\
\noindent $\text{cnt\_cards\_seq}(S, f) \equiv (+ s: \text{CardStackT} | s \in S :
\text{cnt\_cards\_stack}(s, f))$\\

\noindent $\text{cnt\_cards\_stack}: \text{CardStackT} \times (\text{CardT}
\rightarrow \mathbb{B}) \rightarrow \mathbb{N}$\\
\noindent $\text{cnt\_cards\_stack}(S, f) \equiv (+ s: \text{CardT} | s \in S :
1)$\\ \wss{What goes here?}\\

\noindent $\text{cnt\_cards}: \text{SeqCrdStckT} \times \text{SeqCrdStckT}
\times \text{CardStackT} \times \text{CardStackT} \times (\text{CardT}
\rightarrow \mathbb{B}) \rightarrow \mathbb{N}$\\
\noindent $\text{cnt\_cards}(T, F, D, W, f) \equiv \text{cnt\_cards\_seq}(T,
f) + \text{cnt\_cards\_seq}(F, f) + \text{cnt\_cards\_stack}(D, f) +
\text{cnt\_cards\_stack}(W, f)$\\

\noindent $\text{init\_seq}: \mathbb{N} \rightarrow \text{SeqCrdStckT}$\\
\noindent $\text{init\_seq}(n) \equiv s \text{ such that } (|s| = n \land (\forall\, i
\in [0..n-1] : s[i] = \text{CardStackT}(\langle \rangle))$\\

\noindent $\text{tab\_deck}: \text{(seq of CardT)} \rightarrow \text{SeqCrdStckT}$\\
\noindent $\text{tab\_deck} (\mathit{deck}) \equiv T$ such that
$(\forall i: \mathbb{N} | i \in [0..9] : T[i].\text{toSeq}() =
\mathit{deck}[4i..4i+3\wss{\text{What goes here?}}])$\\

\noindent is\_valid\_pos: $ \text{CategoryT} \times \mathbb{N} \rightarrow \mathbb{B}$\\
\noindent is\_valid\_pos($c, n$) $\equiv (c = \text{Tableau} \Rightarrow n \in
[0..9] | c = \text{Foundation} \Rightarrow n \in [0..7] | \text{True} \Rightarrow \text{True})$\\

\noindent valid\_tab\_tab: $\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{B}$\\
\noindent valid\_tab\_tab ($n_0, n_1$) $\equiv$

\begin{tabular}{|p{4cm}|p{3.5cm}|l|}
\hhline{|-|-|-|}
$T[n_0].\text{size}() > 0$ & T[$n_1$].size() $>$ 0 & True \wss{What goes here?}\\
\hhline{|~|-|-|}
 & T[$n_1$].size() = 0 & True \wss{What goes here?}\\
\hhline{|-|-|-|}
T[$n_0$].size() = 0 & T[$n_1$].size() $>$ 0 & False \wss{What goes here?}\\
\hhline{|~|-|-|}
& T[$n_1$].size() $=$ 0 & False \wss{What goes here?}\\
\hhline{|-|-|-|}
\end{tabular}\\\\

\noindent valid\_tab\_foundation: $\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{B}$\\
\noindent valid\_tab\_foundation($n_0, n_1$) $\equiv$ \wss{What goes here?  You
  may need a table?}\\
  
\begin{tabular}{|p{4cm}|p{3.5cm}|l|}
\hhline{|-|-|-|}
$T[n_0].\text{size}() > 0$ & F[$n_1$].size() $>$ 0 & True \\
\hhline{|~|-|-|}
 & F[$n_1$].size() = 0 & True \\
\hhline{|-|-|-|}
T[$n_0$].size() = 0 & F[$n_1$].size() $>$ 0 & False \\
\hhline{|~|-|-|}
& F[$n_1$].size() $=$ 0 & False \\
\hhline{|-|-|-|}
\end{tabular}\\\\

\noindent valid\_waste\_tab: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent valid\_waste\_tab ($n$) $\equiv$

\begin{tabular}{|p{4cm}|l|}
\hhline{|-|-|}
T[$n$].size() $>$ 0 & tab\_placeable(W.top(), T[$n$].top())\\
\hhline{|-|-|}
T[$n$].size() = 0 & True\\
\hhline{|-|-|}
\end{tabular}\\\\

\noindent valid\_waste\_foundation: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent valid\_waste\_foundation ($n$) $\equiv$

\begin{tabular}{|p{4cm}|l|}
\hhline{|-|-|}
F[$n$].size() $>$ 0 & foundation\_placeable(W.top(), F[$n$].top())\\
\hhline{|-|-|}
F[$n$].size() = 0 & W.top().r = ACE\\
\hhline{|-|-|}
\end{tabular}\\\\

\noindent tab\_placeable: CardT $\times$ Card T $\rightarrow \mathbb{B}$\\
$(\forall n_0, n_1: CardT| n_0, n_1 \in T: (n_0.s = n_1.s) \land (n_0.r + 1 = n_1.r))$


\wss{Complete this specification}\\

\noindent foundation\_placeable:$(\forall n_0, n_1: CardT| n_0, n_1 \in F: (n_0.s = n_1.s) \land (n_0.r = n_1.r + 1))$ \wss{Complete this specification}


\newpage

\section*{Critique of Design}




\wss{Write a critique of the interface for the modules in this project.  Is there
anything missing?  Is there anything you would consider changing?  Why?}\\

There are many parts in the critique that are redundant and unused within the specification. For example, in the CardTypes Module, in the exported constants only TOTAL\_CARDS is used in the other modules. The values given to the face cards ACE, JACK, QUEEN, KING are largely unused and merely serve as a way to clarify to the user where these cards fall in values because they are not straight forward in rank like the number cards. A way to change this to reduce redundancy would be to specify this in the assumptions instead to limit the use of unused exported constants.

This redundancy extends to the Game Board Module. Many of the local functions are unused in the specification, such as the several count card location functions as well as tab\_placeable and foundation\_placeable. Because they are unused in the exported functions there is little point in keeping them within the specification, and for the interest of clarity can be removed.

Additionally, the Game Board Module is fairly bloated and only keeps track of the state of the game, details regarding whether a move is valid besides checking if the stack is empty are left out (for example, that tableau moves can only be done with the same suit and according descending rank). It may be preferable to further split up the Game Board Module into several modules, for example a module that handles the rules for moving from the tableau, moving from the waste etc. While this would increase the hierarchy and dependency of the Game Board Module on other modules, it would be easier to maintain and make changes to the rules for a given aspect of the game.

\end {document}